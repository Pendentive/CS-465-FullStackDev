/* tslint:disable */
/* eslint-disable */

// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //

// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.

import mongoose from "mongoose";

/**
 * Lean version of GalleryBannerDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GalleryBannerDocument.toObject()`. To avoid conflicts with model names, use the type alias `GalleryBannerObject`.
 * ```
 * const gallerybannerObject = gallerybanner.toObject();
 * ```
 */
export type GalleryBanner = {
  title: string;
  description?: string;
  images: (Image["_id"] | Image)[];
  photoEdgeLength?: number;
  barHeight?: number;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of GalleryBannerDocument (type alias of `GalleryBanner`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { GalleryBanner } from "../models"
 * import { GalleryBannerObject } from "../interfaces/mongoose.gen.ts"
 *
 * const gallerybannerObject: GalleryBannerObject = gallerybanner.toObject();
 * ```
 */
export type GalleryBannerObject = GalleryBanner;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GalleryBannerQuery = mongoose.Query<
  any,
  GalleryBannerDocument,
  GalleryBannerQueries
> &
  GalleryBannerQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `GalleryBannerSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GalleryBannerQueries = {};

export type GalleryBannerMethods = {};

export type GalleryBannerStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GalleryBanner = mongoose.model<GalleryBannerDocument, GalleryBannerModel>("GalleryBanner", GalleryBannerSchema);
 * ```
 */
export type GalleryBannerModel = mongoose.Model<
  GalleryBannerDocument,
  GalleryBannerQueries
> &
  GalleryBannerStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new GalleryBanner schema instances:
 * ```
 * const GalleryBannerSchema: GalleryBannerSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GalleryBannerSchema = mongoose.Schema<
  GalleryBannerDocument,
  GalleryBannerModel,
  GalleryBannerMethods,
  GalleryBannerQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GalleryBanner = mongoose.model<GalleryBannerDocument, GalleryBannerModel>("GalleryBanner", GalleryBannerSchema);
 * ```
 */
export type GalleryBannerDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GalleryBannerQueries
> &
  GalleryBannerMethods & {
    title: string;
    description?: string;
    images: mongoose.Types.Array<ImageDocument["_id"] | ImageDocument>;
    photoEdgeLength?: number;
    barHeight?: number;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of GalleryGridDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GalleryGridDocument.toObject()`. To avoid conflicts with model names, use the type alias `GalleryGridObject`.
 * ```
 * const gallerygridObject = gallerygrid.toObject();
 * ```
 */
export type GalleryGrid = {
  title: string;
  description?: string;
  images: (Image["_id"] | Image)[];
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of GalleryGridDocument (type alias of `GalleryGrid`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { GalleryGrid } from "../models"
 * import { GalleryGridObject } from "../interfaces/mongoose.gen.ts"
 *
 * const gallerygridObject: GalleryGridObject = gallerygrid.toObject();
 * ```
 */
export type GalleryGridObject = GalleryGrid;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GalleryGridQuery = mongoose.Query<
  any,
  GalleryGridDocument,
  GalleryGridQueries
> &
  GalleryGridQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `GalleryGridSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GalleryGridQueries = {};

export type GalleryGridMethods = {};

export type GalleryGridStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GalleryGrid = mongoose.model<GalleryGridDocument, GalleryGridModel>("GalleryGrid", GalleryGridSchema);
 * ```
 */
export type GalleryGridModel = mongoose.Model<
  GalleryGridDocument,
  GalleryGridQueries
> &
  GalleryGridStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new GalleryGrid schema instances:
 * ```
 * const GalleryGridSchema: GalleryGridSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GalleryGridSchema = mongoose.Schema<
  GalleryGridDocument,
  GalleryGridModel,
  GalleryGridMethods,
  GalleryGridQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GalleryGrid = mongoose.model<GalleryGridDocument, GalleryGridModel>("GalleryGrid", GalleryGridSchema);
 * ```
 */
export type GalleryGridDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GalleryGridQueries
> &
  GalleryGridMethods & {
    title: string;
    description?: string;
    images: mongoose.Types.Array<ImageDocument["_id"] | ImageDocument>;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of GalleryHeroVertDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GalleryHeroVertDocument.toObject()`. To avoid conflicts with model names, use the type alias `GalleryHeroVertObject`.
 * ```
 * const galleryherovertObject = galleryherovert.toObject();
 * ```
 */
export type GalleryHeroVert = {
  title: string;
  description?: string;
  images: (Image["_id"] | Image)[];
  padding?: number;
  width?: number;
  height?: number;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of GalleryHeroVertDocument (type alias of `GalleryHeroVert`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { GalleryHeroVert } from "../models"
 * import { GalleryHeroVertObject } from "../interfaces/mongoose.gen.ts"
 *
 * const galleryherovertObject: GalleryHeroVertObject = galleryherovert.toObject();
 * ```
 */
export type GalleryHeroVertObject = GalleryHeroVert;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GalleryHeroVertQuery = mongoose.Query<
  any,
  GalleryHeroVertDocument,
  GalleryHeroVertQueries
> &
  GalleryHeroVertQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `GalleryHeroVertSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GalleryHeroVertQueries = {};

export type GalleryHeroVertMethods = {};

export type GalleryHeroVertStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GalleryHeroVert = mongoose.model<GalleryHeroVertDocument, GalleryHeroVertModel>("GalleryHeroVert", GalleryHeroVertSchema);
 * ```
 */
export type GalleryHeroVertModel = mongoose.Model<
  GalleryHeroVertDocument,
  GalleryHeroVertQueries
> &
  GalleryHeroVertStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new GalleryHeroVert schema instances:
 * ```
 * const GalleryHeroVertSchema: GalleryHeroVertSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GalleryHeroVertSchema = mongoose.Schema<
  GalleryHeroVertDocument,
  GalleryHeroVertModel,
  GalleryHeroVertMethods,
  GalleryHeroVertQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GalleryHeroVert = mongoose.model<GalleryHeroVertDocument, GalleryHeroVertModel>("GalleryHeroVert", GalleryHeroVertSchema);
 * ```
 */
export type GalleryHeroVertDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GalleryHeroVertQueries
> &
  GalleryHeroVertMethods & {
    title: string;
    description?: string;
    images: mongoose.Types.Array<ImageDocument["_id"] | ImageDocument>;
    padding?: number;
    width?: number;
    height?: number;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of ImageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ImageDocument.toObject()`. To avoid conflicts with model names, use the type alias `ImageObject`.
 * ```
 * const imageObject = image.toObject();
 * ```
 */
export type Image = {
  filename: string;
  path: string;
  category?: string;
  metadata: {
    width?: number;
    height?: number;
    size?: number;
    dateCreated?: Date;
  };
  alt?: string;
  title?: string;
  description?: string;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of ImageDocument (type alias of `Image`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Image } from "../models"
 * import { ImageObject } from "../interfaces/mongoose.gen.ts"
 *
 * const imageObject: ImageObject = image.toObject();
 * ```
 */
export type ImageObject = Image;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ImageQuery = mongoose.Query<any, ImageDocument, ImageQueries> &
  ImageQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ImageSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ImageQueries = {};

export type ImageMethods = {};

export type ImageStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Image = mongoose.model<ImageDocument, ImageModel>("Image", ImageSchema);
 * ```
 */
export type ImageModel = mongoose.Model<ImageDocument, ImageQueries> &
  ImageStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Image schema instances:
 * ```
 * const ImageSchema: ImageSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ImageSchema = mongoose.Schema<
  ImageDocument,
  ImageModel,
  ImageMethods,
  ImageQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Image = mongoose.model<ImageDocument, ImageModel>("Image", ImageSchema);
 * ```
 */
export type ImageDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ImageQueries
> &
  ImageMethods & {
    filename: string;
    path: string;
    category?: string;
    metadata: {
      width?: number;
      height?: number;
      size?: number;
      dateCreated?: Date;
    };
    alt?: string;
    title?: string;
    description?: string;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of RepeaterMenuMenuCardDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RepeaterMenuDocument.toObject()`.
 * ```
 * const repeatermenuObject = repeatermenu.toObject();
 * ```
 */
export type RepeaterMenuMenuCard = {
  title: string;
  image: Image["_id"] | Image;
  route: string;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of RepeaterMenuDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RepeaterMenuDocument.toObject()`. To avoid conflicts with model names, use the type alias `RepeaterMenuObject`.
 * ```
 * const repeatermenuObject = repeatermenu.toObject();
 * ```
 */
export type RepeaterMenu = {
  menuCards: RepeaterMenuMenuCard[];
  photoHeight?: number;
  photoWidth?: number;
  photoPaddingX?: number;
  photoPaddingY?: number;
  menuCardPaddingX?: number;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of RepeaterMenuDocument (type alias of `RepeaterMenu`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { RepeaterMenu } from "../models"
 * import { RepeaterMenuObject } from "../interfaces/mongoose.gen.ts"
 *
 * const repeatermenuObject: RepeaterMenuObject = repeatermenu.toObject();
 * ```
 */
export type RepeaterMenuObject = RepeaterMenu;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RepeaterMenuQuery = mongoose.Query<
  any,
  RepeaterMenuDocument,
  RepeaterMenuQueries
> &
  RepeaterMenuQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `RepeaterMenuSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RepeaterMenuQueries = {};

export type RepeaterMenuMethods = {};

export type RepeaterMenuStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const RepeaterMenu = mongoose.model<RepeaterMenuDocument, RepeaterMenuModel>("RepeaterMenu", RepeaterMenuSchema);
 * ```
 */
export type RepeaterMenuModel = mongoose.Model<
  RepeaterMenuDocument,
  RepeaterMenuQueries
> &
  RepeaterMenuStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new RepeaterMenu schema instances:
 * ```
 * const RepeaterMenuSchema: RepeaterMenuSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RepeaterMenuSchema = mongoose.Schema<
  RepeaterMenuDocument,
  RepeaterMenuModel,
  RepeaterMenuMethods,
  RepeaterMenuQueries
>;

/**
 * Mongoose Subdocument type
 *
 * Type of `RepeaterMenuDocument["menuCards"]` element.
 */
export type RepeaterMenuMenuCardDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    title: string;
    image: ImageDocument["_id"] | ImageDocument;
    route: string;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const RepeaterMenu = mongoose.model<RepeaterMenuDocument, RepeaterMenuModel>("RepeaterMenu", RepeaterMenuSchema);
 * ```
 */
export type RepeaterMenuDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RepeaterMenuQueries
> &
  RepeaterMenuMethods & {
    menuCards: mongoose.Types.DocumentArray<RepeaterMenuMenuCardDocument>;
    photoHeight?: number;
    photoWidth?: number;
    photoPaddingX?: number;
    photoPaddingY?: number;
    menuCardPaddingX?: number;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of TypeIntroDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `TypeIntroDocument.toObject()`. To avoid conflicts with model names, use the type alias `TypeIntroObject`.
 * ```
 * const typeintroObject = typeintro.toObject();
 * ```
 */
export type TypeIntro = {
  title: string;
  description?: string;
  leftPadding: number;
  width: number;
  height: number;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of TypeIntroDocument (type alias of `TypeIntro`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { TypeIntro } from "../models"
 * import { TypeIntroObject } from "../interfaces/mongoose.gen.ts"
 *
 * const typeintroObject: TypeIntroObject = typeintro.toObject();
 * ```
 */
export type TypeIntroObject = TypeIntro;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type TypeIntroQuery = mongoose.Query<
  any,
  TypeIntroDocument,
  TypeIntroQueries
> &
  TypeIntroQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `TypeIntroSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type TypeIntroQueries = {};

export type TypeIntroMethods = {};

export type TypeIntroStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const TypeIntro = mongoose.model<TypeIntroDocument, TypeIntroModel>("TypeIntro", TypeIntroSchema);
 * ```
 */
export type TypeIntroModel = mongoose.Model<
  TypeIntroDocument,
  TypeIntroQueries
> &
  TypeIntroStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new TypeIntro schema instances:
 * ```
 * const TypeIntroSchema: TypeIntroSchema = new mongoose.Schema({ ... })
 * ```
 */
export type TypeIntroSchema = mongoose.Schema<
  TypeIntroDocument,
  TypeIntroModel,
  TypeIntroMethods,
  TypeIntroQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const TypeIntro = mongoose.model<TypeIntroDocument, TypeIntroModel>("TypeIntro", TypeIntroSchema);
 * ```
 */
export type TypeIntroDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  TypeIntroQueries
> &
  TypeIntroMethods & {
    title: string;
    description?: string;
    leftPadding: number;
    width: number;
    height: number;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of UsersDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `UsersDocument.toObject()`. To avoid conflicts with model names, use the type alias `UsersObject`.
 * ```
 * const usersObject = users.toObject();
 * ```
 */
export type Users = {
  email: string;
  name: string;
  hash?: string;
  salt?: string;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of UsersDocument (type alias of `Users`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Users } from "../models"
 * import { UsersObject } from "../interfaces/mongoose.gen.ts"
 *
 * const usersObject: UsersObject = users.toObject();
 * ```
 */
export type UsersObject = Users;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type UsersQuery = mongoose.Query<any, UsersDocument, UsersQueries> &
  UsersQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `UsersSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type UsersQueries = {};

export type UsersMethods = {
  setPassword: (this: UsersDocument, ...args: any[]) => any;
  validPassword: (this: UsersDocument, ...args: any[]) => any;
  generateJwt: (this: UsersDocument, ...args: any[]) => any;
};

export type UsersStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Users = mongoose.model<UsersDocument, UsersModel>("Users", UsersSchema);
 * ```
 */
export type UsersModel = mongoose.Model<UsersDocument, UsersQueries> &
  UsersStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Users schema instances:
 * ```
 * const UsersSchema: UsersSchema = new mongoose.Schema({ ... })
 * ```
 */
export type UsersSchema = mongoose.Schema<
  UsersDocument,
  UsersModel,
  UsersMethods,
  UsersQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Users = mongoose.model<UsersDocument, UsersModel>("Users", UsersSchema);
 * ```
 */
export type UsersDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  UsersQueries
> &
  UsersMethods & {
    email: string;
    name: string;
    hash?: string;
    salt?: string;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
  return doc instanceof mongoose.Document;
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never;

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never;

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
  [ref in T]: Root[T] extends mongoose.Types.Array<infer U>
    ? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
    : Exclude<Root[T], mongoose.Types.ObjectId>;
};

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
  ? PopulatedProperty<DocType, T>
  : ParentProperty<T> extends keyof DocType
  ? Omit<DocType, ParentProperty<T>> & {
      [ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<
        infer U
      >
        ? mongoose.Types.Array<
            ChildProperty<T> extends keyof U
              ? PopulatedProperty<U, ChildProperty<T>>
              : PopulatedDocument<U, ChildProperty<T>>
          >
        : ChildProperty<T> extends keyof DocType[ParentProperty<T>]
        ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
        : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>;
    }
  : DocType;

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T;
type Modify<T, R> = Omit<T, keyof R> & R;

/**
 * Augment mongoose with Query.populate overloads
 */
declare module "mongoose" {
  interface Query<ResultType, DocType, THelpers = {}> {
    populate<T extends string>(
      path: T,
      select?: string | any,
      model?: string | Model<any, THelpers>,
      match?: any
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers;

    populate<T extends string>(
      options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers;
  }
}
